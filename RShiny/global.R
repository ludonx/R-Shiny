

# Shiny stuff
library(shiny)
library(shinyjs)
library(shinyAce)
library(shinycssloaders)
library(shinydashboard)
library(shinyWidgets) # pickerInput  (voir module réglage)

# data parsing
library(readr)#read_file

# database
library(mongolite)
library(jsonlite)
library(DT)
library(bcrypt) #passowrd hashing

# vizualisation
library(ggplot2)
library(gridExtra)
library(plotly)
library(pheatmap)

# data processing
library(reshape) 
library(stringr) #use for str_sub
library(dplyr) #distinct

# for module bast
library(RLinuxModules)
library(seqinr)
library(RFLPtools)


#-----------------------------------------------------------------------------------------#
# main object container ----
#-----------------------------------------------------------------------------------------#
# this list will contain all the data generated by the application
app <- list()
# table with installation/config information
app$config <- read_json(path='./config.json',simplifyVector = TRUE)

# Sanity check of the configuration file
if(sum(as.logical(app$config$activated)) != 1)
{
  stop("sanity check: only one configuration can be active")
}

app$config <- app$config[as.logical(app$config$activated),]

# check path existence
if(!file.exists(app$config$workDirectory))
{
  stop("sanity check: working directory does not exist")
}  



#-----------------------------------------------------------------------------------------#
# misc libraries ----
#-----------------------------------------------------------------------------------------#
source(paste0(app$config$appDirectory,"/R/PackageForAdmin/mesFonctionUtiles.R"))
source(paste0(app$config$appDirectory,"/R/PackageForGgplot2/mesFonctionsGgplot2.R"))

#-----------------------------------------------------------------------------------------#



#-----------------------------------------------------------------------------------------#
# user data and information ----
#-----------------------------------------------------------------------------------------#
app$users <- list()
app$usersTracking <- data.frame()

#-----------------------------------------------------------------------------------------#
# database code and connections ----
#-----------------------------------------------------------------------------------------#
app$db <- list() # cette variable n'est pas utilisé
# launch code that creates a connection using config settings
source(paste0(app$config$appDirectory,"/R/PackageForMongoDB/mesFonctionsNoSQL.R"))
source(paste0(app$config$appDirectory,"/R/PackageForMongoDB/mongoDbSimpleQuery.R"))

# launch code that generate the functions use by the admin to manage the database
source(paste0(app$config$appDirectory,"/R/PackageForAdmin/ManagingDataBase/ajouter_un_catalogue.R"))
source(paste0(app$config$appDirectory,"/R/PackageForAdmin/ManagingDataBase/ajouter_un_projet.R"))
source(paste0(app$config$appDirectory,"/R/PackageForAdmin/MesFonctionsAdmin.R"))
source(paste0(app$config$appDirectory,"/R/PackageForAdmin/mesFonctionUtiles.R"))
#-----------------------------------------------------------------------------------------#


#-----------------------------------------------------------------------------------------#
# module data and configuration ----
#-----------------------------------------------------------------------------------------#
app$modules <- list()
app$modules$ui<-list()
app$modules$server<-list()
app$modules$menu<-list()

source(paste0(app$config$appDirectory,"/R/scrirptCreateModule.R"))
# TODO move to folder R all scripts containig function 

#-----------------------------------------------------------------------------------------#


#-----------------------------------------------------------------------------------------#
# build main application ----
#-----------------------------------------------------------------------------------------#
listeUI <- list()
# in the module folder each folder contains a module. there shouldn't be any folders that are not modules.
module.file.names <- dir(path = app$config$pathToModule, pattern = ".json", recursive = T)
df<-data.frame()
# for each module parse configuration files. If it does not finish by config.json the module will be skipped
for(i in 1:length(module.file.names) )
{
  if(endsWith(module.file.names[i],"config.json"))
  {
    
    mod.conf <- read_json(path = paste0(app$config$pathToModule, module.file.names[i]), simplifyVector = TRUE)
    
    # mod.conf$ui contains the name of a variable which itself contains the html code generated by shiny
    if(!is.na(mod.conf$ui)) listeUI <- append(listeUI, mod.conf$ui)
    # mod.conf$server contains a R/shiny function which listens to the events and runs ...
    if(!is.na(mod.conf$server))app$modules$server <- append(app$modules$server, mod.conf$server)
    # mod.conf$menu contains a R/shiny function and binds the module-app to the rest of the application
    if(!is.na(mod.conf$menu)){app$modules$menu<-append(app$modules$menu,mod.conf$menu)}
    #if(!is.na(mod.conf$menu_en)){app$modules$menu_en<-append(app$modules$menu_en,mod.conf$menu_en)
    
    # mod.conf$fileToSource contains all the shiny/R files containing functions
    if(!is.na(mod.conf$fileToSource))
    {
      fileTosource <- unlist(mod.conf$fileToSource)
      for(j in 1:length(fileTosource))
      {
        # on charge les fichiers source
        source(paste0(app$config$pathToModule, mod.conf$folderName,'/',fileTosource[j]))
      }
    }
    
    # on sauvegarde les données de structuration de l'application dans un data frame
    if(i==1)
    {
      
      df<-mod.conf
    }else
    {
      df<-rbind(df,mod.conf)
      
    }
  }#end if(endsWith(module.file.names[i],"config.json"))
}#end for


app$config_df <- df
app$modules$ui <- lapply(listeUI, function(x){eval(parse(text = x))})




